use std::str::FromStr;

use object_model::{ValueRef, HeapValueRef};
use value::ValueManager;
use ast::{Method, Block};

#![arguments(factory: &mut ValueManager)]

pub program -> HeapValueRef<Block> = ws? block:body ws? { block }

body -> HeapValueRef<Block> = stmts:stmt* ws? expr:expr {
    factory.create_block(&stmts, expr).unwrap()
}

stmt -> ValueRef
    = pat:pattern ws? "=" ws? expr:expr ws? ";" ws? {
          factory.create_def(pat, expr).unwrap().into()
      }
    / expr:expr ws? ";" ws? { expr }

pattern -> ValueRef = expr

expr -> ValueRef = e:infix { ValueRef::from(e) }

infix -> ValueRef = #infix<call> {
    #L el op:op6 er { ValueRef::from(factory.create_call(op, &[el, er]).unwrap()) }
    #L el op:op7 er { ValueRef::from(factory.create_call(op, &[el, er]).unwrap()) }
}

op<O> = ws? op:$(O) ws? {
    let sym = factory.create_symbol(op).unwrap();
    ValueRef::from(factory.create_lex(sym).unwrap())
}
op6 -> ValueRef = op<[+\-]>
op7 -> ValueRef = op<[*/%]>

call -> ValueRef
    = callee:simple ws? args:(simple ++ (ws?)) {
          factory.create_call(callee, &args).unwrap().into()
      }
    / e:simple { e }

simple -> ValueRef
    = "{" ws? b:body ws? "}" { ValueRef::from(b) }
    / "{" ws? methods:(method ++ (ws? ";" ws?)) ws? "}" {
        ValueRef::from(factory.create_function(&methods).unwrap())
    }
    / "[" ws? b:body ws? "]" {
        let guard_value = factory.create_bool(true);
        let guard = ValueRef::from(factory.create_const(guard_value).unwrap());
        let method = factory.create_method(/* FIXME: */ guard, guard,ValueRef::from(b)).unwrap();
        ValueRef::from(factory.create_function(&[method]).unwrap())
    }
    / "(" ws? e:expr ws? ")" { e }
    / var:var { var }
    / n:int { ValueRef::from(factory.create_const(n).unwrap()) }

method -> HeapValueRef<Method> = pattern:pattern ws? guard:guard? ws? "=>" ws? body:body {
    let guard = guard.unwrap_or_else(|| {
        let value = factory.create_bool(true);
        ValueRef::from(factory.create_const(value).unwrap())
    });
    factory.create_method(pattern, guard, ValueRef::from(body)).unwrap()
}

guard -> ValueRef = "|" ws? e:expr { e }

var -> ValueRef
    = cs:$([A-Za-z][A-Za-z0-9]*) {
          let sym = factory.create_symbol(cs).unwrap();
          factory.create_lex(sym).unwrap().into()
      }

int -> ValueRef = cs:$([0-9]+) {
  ValueRef::from(factory.create_int(isize::from_str(cs).unwrap()))
}

ws -> () = [ \t\r\n]+
