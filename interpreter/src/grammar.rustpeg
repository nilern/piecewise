use std::str::FromStr;

use value::{Block, Method, ValueManager};
use value_refs::{ValueRef, TypedValueRef};

#![arguments(factory: &mut ValueManager)]

pub program -> TypedValueRef<Block> = ws? block:body ws? { block }

body -> TypedValueRef<Block> = stmts:stmt* ws? expr:expr {
    factory.create_block(&stmts, expr).unwrap()
}

stmt -> ValueRef = expr:expr ws? ";" { expr }

pattern -> ValueRef = n:int { ValueRef::from(factory.create_const(n).unwrap()) }

expr -> ValueRef = e:infix { ValueRef::from(e) }

infix -> ValueRef = #infix<simple> {
    #L el op:op6 er { ValueRef::from(factory.create_call(op, &[el, er]).unwrap()) }
    #L el op:op7 er { ValueRef::from(factory.create_call(op, &[el, er]).unwrap()) }
}

op<O> = ws? op:$(O) ws? {
    let sym = factory.create_symbol(op).unwrap();
    ValueRef::from(factory.create_lex(sym).unwrap())
}
op6 -> ValueRef = op<[+\-]>
op7 -> ValueRef = op<[*/%]>

simple -> ValueRef
    = "{" ws? b:body ws? "}" { ValueRef::from(b) }
    / "{" ws? methods:(method ++ (ws? ";" ws?)) ws? "}" {
        ValueRef::from(factory.create_function(&methods).unwrap())
    }
    / "[" ws? b:body ws? "]" {
        let guard_value = factory.create_bool(true);
        let guard = ValueRef::from(factory.create_const(guard_value).unwrap());
        let method = factory.create_method(/* FIXME: */ guard, guard,ValueRef::from(b)).unwrap();
        ValueRef::from(factory.create_function(&[method]).unwrap())
    }
    / "(" ws? e:expr ws? ")" { e }
    / n:int { ValueRef::from(factory.create_const(n).unwrap()) }

method -> TypedValueRef<Method> = pattern:pattern ws? guard:guard? ws? "=>" ws? body:body {
    let guard = guard.unwrap_or_else(|| {
        let value = factory.create_bool(true);
        ValueRef::from(factory.create_const(value).unwrap())
    });
    factory.create_method(pattern, guard, ValueRef::from(body)).unwrap()
}

guard -> ValueRef = "|" ws? e:expr { e }

int -> ValueRef = cs:$([0-9]+) {
  ValueRef::from(factory.create_int(isize::from_str(cs).unwrap()))
}

ws -> () = [ \t\r\n]+
