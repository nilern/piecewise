use std::str::FromStr;
use gc::Gc;

use value::{Value, ValueRef};

pub program -> Value = ws? block:body ws? { block }

body -> Value = stmts:stmt* ws? expr:expr { Value::Block { stmts, expr: Gc::new(expr) } }

stmt -> ValueRef = expr:expr ws? ";" { Gc::new(expr) }

pattern -> Value = n:int { Value::Const(Gc::new(Value::Int(n))) }

expr -> Value = infix

infix -> Value = #infix<simple> {
    #L el op:op6 er { Value::Call { callee: Gc::new(op), args: vec![Gc::new(el), Gc::new(er)] } }
    #L el op:op7 er { Value::Call { callee: Gc::new(op), args: vec![Gc::new(el), Gc::new(er)] } }
}

op<O> = ws? op:$(O) ws? { Value::Lex(Gc::new(Value::Symbol(op.to_string()))) }
op6 -> Value = op<[+\-]>
op7 -> Value = op<[*/%]>

simple -> Value
    = "{" ws? b:body ws? "}" { b }
    / "{" ws? methods:(method ++ (ws? ";" ws?)) ws? "}" { Value::Function { methods } }
    / "[" ws? b:body ws? "]" { Value::Function {
          methods: vec![Gc::new(Value::Method {
              pattern: Gc::new(Value::Const(Gc::new(Value::Bool(true)))), // FIXME
              guard: Gc::new(Value::Const(Gc::new(Value::Bool(true)))),
              body: Gc::new(b)
          })]}
      }
    / "(" ws? e:expr ws? ")" { e }
    / n:int { Value::Const(Gc::new(Value::Int(n))) }

method -> ValueRef = pattern:pattern ws? guard:guard? ws? "=>" ws? body:body {
    Gc::new(Value::Method {
        pattern: Gc::new(pattern),
        guard: Gc::new(guard.unwrap_or_else(|| Value::Const(Gc::new(Value::Bool(false))))),
        body: Gc::new(body)
    })
}

guard -> Value = "|" ws? e:expr { e }

int -> isize = cs:$([0-9]+) { isize::from_str(cs).unwrap() }

ws -> () = [ \t\r\n]+
