use std::convert::TryFrom;
use gc::Gc;

use util::SrcPos;
use lexer::{Precedence, Tok, LexicalError};
use lexer::Side::*;
use lexer::Delimiter::*;
use lexer::Separator::*;
use value::Value;
use ast::{Pattern, Expr, Stmt, Block, Function, Method, Call, Name, Def, Clause, analyze_clauses};

#[LALR] grammar;

// -------------------------------------------------------------------------------------------------

pub Program: Block = Body;

Body: Block = {
    <stmts: (<Stmt> ";")*> <expr: Expr> => Block { stmts, expr: Gc::new(expr) }
};

Stmt: Stmt = {
    <pattern: Expr> <guard: ("|" <Expr>)?> "=" <value: Expr> => Stmt::Def(Def {
        pattern: Pattern::try_from(&pattern).unwrap(),
        guard: guard.unwrap_or_else(|| Expr::Const(Gc::new(Value::Bool(true)))),
        value
    }),
    <expr: Expr> => Stmt::Expr(expr)
};

Expr: Expr = Infix1;

Infix1: Expr = <Infix<Infix1, Op1, Infix2>>;

Infix2: Expr = <Infix<Infix2, Op2, Infix3>>;

Infix3: Expr = <Infix<Infix3, Op3, Infix4>>;

Infix4: Expr = <Infix<Infix4, Op4, Infix5>>;

Infix5: Expr = <Infix<Infix5, Op5, Infix6>>;

Infix6: Expr = <Infix<Infix6, Op6, Infix7>>;

Infix7: Expr = <Infix<Infix7, Op7, Call>>;

Call: Expr = {
    <callee: Simple> <args: Simple+> => Expr::Call(Call { callee: Gc::new(callee), args }),
    Simple
};

Simple: Expr = {
    "(" <Expr> ")",
    "{" <clauses: (<Clause> ";")*> <clause: Clause> "}" => {
        let mut clauses = clauses;
        clauses.push(clause);
        analyze_clauses(clauses).unwrap()
    },
    "[" <body: Body> "]" => Expr::Function(Gc::new(Function(vec![Method {
        pattern: Pattern::Const(Gc::new(Value::Bool(true))), // FIXME
        guard: Expr::Const(Gc::new(Value::Bool(true))),
        body: Expr::Block(body)
    }]))),
    
    <name: Name> => Expr::NameRef(Name::Lex(name)),
    <c: Const> => Expr::Const(c) 
};

Clause: Clause = {
    <pattern: Expr> <guard: ("|" <Expr>)?> "=>" <body: Stmt> => Clause::Method {
        pattern: Pattern::try_from(&pattern).unwrap(),
        guard: guard.unwrap_or_else(|| Expr::Const(Gc::new(Value::Bool(true)))),
        body
    },
    <stmt: Stmt> => Clause::Stmt(stmt)  
};

Const: Gc<Value> = {
    <n: Int> => Gc::new(Value::Int(n))
};

// -------------------------------------------------------------------------------------------------

Infix<Self, Op, Next>: Expr = {
    <l: Self> <op: Op> <r: Next> => Expr::Call(Call {
        callee: Gc::new(Expr::NameRef(Name::Lex(op))),
        args: vec![l, r]
    }),
    <Next>
};

// -------------------------------------------------------------------------------------------------

extern {
    type Location = SrcPos;
    type Error = LexicalError;
    enum Tok {
        Name => Tok::Name(<String>),
        Int => Tok::Int(<isize>),
        String => Tok::String(<String>),
        Char => Tok::Char(<String>),
        Op0 => Tok::Op(<String>, Precedence::Zero),
        Op1 => Tok::Op(<String>, Precedence::One),
        Op2 => Tok::Op(<String>, Precedence::Two),
        Op3 => Tok::Op(<String>, Precedence::Three),
        Op4 => Tok::Op(<String>, Precedence::Four),
        Op5 => Tok::Op(<String>, Precedence::Five),
        Op6 => Tok::Op(<String>, Precedence::Six),
        Op7 => Tok::Op(<String>, Precedence::Seven),
        "(" => Tok::Delim(Paren, Left),
        ")" => Tok::Delim(Paren, Right),
        "[" => Tok::Delim(Bracket, Left),
        "]" => Tok::Delim(Bracket, Right),
        "{" => Tok::Delim(Brace, Left),
        "}" => Tok::Delim(Brace, Right),
        "," => Tok::Sep(Comma),
        ";" => Tok::Sep(Semicolon),
        "=>" => Tok::Arrow,
        "=" => Tok::Eq,
        "|" => Tok::Bar
    }
}
