use std::str::FromStr;

use pcws_domain::Allocator;
use pcws_domain::object_model::{ValueRef, ValueRefT};
use pcws_domain::values::Symbol;
use ast::{Block, Def, Function, Method, Call, Lex, Const};

// FIXME: unwrappy

#![arguments(allocator: &mut Allocator)]

pub program -> ValueRefT<Block> = ws? block:body ws? { block }

body -> ValueRefT<Block> = stmts:stmt* ws? expr:expr {
    Block::new(allocator, &stmts, expr).unwrap()
}

stmt -> ValueRef
    = pat:pattern ws? "=" ws? expr:expr ws? ";" ws? {
          Def::new(allocator, pat, expr).unwrap().into()
      }
    / expr:expr ws? ";" ws? { expr }

pattern -> ValueRef = expr

expr -> ValueRef = e:infix { ValueRef::from(e) }

infix -> ValueRef = #infix<call> {
    #L el op:op6 er { Call::new(allocator, op, &[el, er]).unwrap().into() }
    #L el op:op7 er { Call::new(allocator, op, &[el, er]).unwrap().into() }
}

op<O> = ws? op:$(O) ws? {
    let sym = Symbol::new(allocator, op).unwrap();
    Lex::new(allocator, sym).unwrap().into()
}
op6 -> ValueRef = op<[+\-]>
op7 -> ValueRef = op<[*/%]>

call -> ValueRef
    = callee:simple ws? args:(simple ++ (ws?)) {
          Call::new(allocator, callee, &args).unwrap().into()
      }
    / e:simple { e }

simple -> ValueRef
    = "{" ws? b:body ws? "}" { b.into() }
    / "{" ws? methods:(method ++ (ws? ";" ws?)) ws? "}" {
        Function::new(allocator, &methods).unwrap().into()
    }
    / "[" ws? b:body ws? "]" {
        let guard_value: ValueRefT<bool> = true.into();
        let guard = Const::new(allocator, guard_value.into()).unwrap().into();
        let method = Method::new(allocator, /* FIXME: */ guard, guard, b.into()).unwrap();
        Function::new(allocator, &[method]).unwrap().into()
    }
    / "(" ws? e:expr ws? ")" { e }
    / var:var { var }
    / c:constant { c.into() }

method -> ValueRefT<Method> = pattern:pattern ws? guard:guard? ws? "=>" ws? body:body {
    let guard = guard.unwrap_or_else(|| {
        let value: ValueRefT<bool> = true.into();
        Const::new(allocator, value.into()).unwrap().into()
    });
    Method::new(allocator, pattern, guard, body.into()).unwrap()
}

guard -> ValueRef = "|" ws? e:expr { e }

var -> ValueRef
    = cs:$([A-Za-z][A-Za-z0-9]*) {
          let sym = Symbol::new(allocator, cs).unwrap().into();
          Lex::new(allocator, sym).unwrap().into()
      }

constant -> ValueRefT<Const> = n:int { Const::new(allocator, n).unwrap() }

int -> ValueRef = cs:$([0-9]+) {
    ValueRefT::from(isize::from_str(cs).unwrap()).into()
}

ws -> () = [ \t\r\n]+
