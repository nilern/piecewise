use std::str::FromStr;

use cst::{Pos, Expr, Pattern, Stmt, Method, Const};

pub program -> Expr = ws? block:body ws? { block }

body -> Expr = stmts:stmt* ws? expr:expr {
    Expr::Block(Pos::default(), stmts, Box::new(expr))
}

stmt -> Stmt
    = pat:pattern ws? "=" ws? expr:expr ws? ";" ws? { Stmt::Def(pat, expr) }
    / expr:expr ws? ";" ws? { Stmt::Expr(expr) }

pattern -> Pattern = lex:lex { Pattern::Lex(Pos::default(), lex) }

expr -> Expr = infix

infix -> Expr = #infix<call> {
    #L el op:op6 er { Expr::Call(Pos::default(), Box::new(op), vec![el, er]) }
    #L el op:op7 er { Expr::Call(Pos::default(), Box::new(op), vec![el, er]) }
}

op<O> = ws? op:$(O) ws? { Expr::Lex(Pos::default(), op.to_string()) }
op6 -> Expr = op<[+\-]>
op7 -> Expr = op<[*/%]>

call -> Expr
    = callee:simple ws? args:(simple ++ (ws?)) {
        Expr::Call(Pos::default(), Box::new(callee), args)
    }
    / e:simple { e }

simple -> Expr
    = "{" ws? b:body ws? "}" { b }
    / "{" ws? methods:(method ++ (ws? ";" ws?)) ws? "}" {
        Expr::Function(Pos::default(), methods)
    }
    / "[" ws? body:body ws? "]" {
        let guard = Expr::Const(Pos::default(), Const::Bool(true));
        let method = Method { params: Vec::new(), guard, body };
        Expr::Function(Pos::default(), vec![method])
    }
    / "(" ws? e:expr ws? ")" { e }
    / name:lex { Expr::Lex(Pos::default(), name) }
    / c:constant { Expr::Const(Pos::default(), c) }

method -> Method = pattern:pattern ws? guard:guard? ws? "=>" ws? body:body {
    let guard = guard.unwrap_or_else(|| Expr::Const(Pos::default(), Const::Bool(true)));
    Method { params: vec![pattern], guard, body }
}

guard -> Expr = "|" ws? e:expr { e }

lex -> String
    = cs:$([A-Za-z][A-Za-z0-9]*) { cs.to_string() }

constant -> Const = n:int { Const::Int(n) }

int -> isize = cs:$([0-9]+) { isize::from_str(cs).unwrap() }

ws -> () = [ \t\r\n]+
