use std::str::FromStr;

use cst::{Id, IdFactory, Pos, Expr, Pattern, Stmt, Case, Const};

#![arguments(id_factory: &mut IdFactory)]

pub program -> Expr = ws? block:body ws? { block }

body -> Expr = stmts:stmt* ws? expr:expr {
    Expr::Block(Pos::default(), stmts, Box::new(expr))
}

stmt -> Stmt
    = pat:pattern ws? "=" ws? expr:expr ws? ";" ws? { Stmt::Def(pat, expr) }
    / expr:expr ws? ";" ws? { Stmt::Expr(expr) }

pattern -> Pattern = lex:lex { Pattern::Lex(Pos::default(), lex) }

expr -> Expr = infix

infix -> Expr = #infix<call> {
    #L el op:op6 er { Expr::Call(Pos::default(), Box::new(op), vec![el, er]) }
    #L el op:op7 er { Expr::Call(Pos::default(), Box::new(op), vec![el, er]) }
}

op<O> = ws? op:$(O) ws? { Expr::Lex(Pos::default(), id_factory.get(op)) }
op6 -> Expr = op<[+\-]>
op7 -> Expr = op<[*/%]>

call -> Expr
    = callee:simple ws? args:(simple ++ (ws?)) {
        Expr::Call(Pos::default(), Box::new(callee), args)
    }
    / e:simple { e }

simple -> Expr
    = "{" ws? b:body ws? "}" { b }
    / "{" ws? methods:(method ++ (ws? ";" ws?)) ws? "}" {
        let closure = id_factory.fresh("self");
        let args = id_factory.fresh("args");
        Expr::Function(Pos::default(), vec![], // FIXME
            Box::new(Expr::Match(Pos::default(),
                methods,
                Box::new(Case {
                    patterns: Vec::new(), // FIXME
                    guard: Expr::Const(Pos::default(), Const::Bool(true)),
                    body: Expr::Call(Pos::default(),
                                     Box::new(Expr::Lex(Pos::default(), closure)),
                                     vec![Expr::Lex(Pos::default(), closure),
                                          Expr::Lex(Pos::default(), args)])
                }))))
    }
    / "[" ws? body:body ws? "]" {
        Expr::Function(Pos::default(), vec![], /* FIXME */ Box::new(body))
    }
    / "(" ws? e:expr ws? ")" { e }
    / name:lex { Expr::Lex(Pos::default(), name) }
    / c:constant { Expr::Const(Pos::default(), c) }

method -> Case = pattern:pattern ws? guard:guard? ws? "=>" ws? body:body {
    let guard = guard.unwrap_or_else(|| Expr::Const(Pos::default(), Const::Bool(true)));
    Case { patterns: vec![pattern], guard, body }
}

guard -> Expr = "|" ws? e:expr { e }

lex -> Id
    = cs:$([A-Za-z][A-Za-z0-9]*) { id_factory.get(cs) }

constant -> Const = n:int { Const::Int(n) }

int -> isize = cs:$([0-9]+) { isize::from_str(cs).unwrap() }

ws -> () = [ \t\r\n]+
