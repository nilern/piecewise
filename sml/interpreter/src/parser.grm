datatype block_item = MethodHeader of Value.expr * Value.expr option
                    | Stmt of Value.stmt

(* HACK: raise Fail ... *)
local
    fun parseBlockPrefix (items as (MethodHeader _ :: _)) = (NONE, items)
      | parseBlockPrefix (Stmt stmt :: items) =
        (case parseBlockPrefix items
         of (SOME (stmts, expr), tail) => (SOME (stmt :: stmts, expr), tail)
          | (NONE, tail) =>
             (case stmt
              of Value.Expr expr => (SOME ([], expr), tail)
               | _ => raise Fail "block ends in non-expression"))
      | parseBlockPrefix [] = (NONE, [])

    fun parseFn pos items =
        let fun parseMethods (MethodHeader (pat, guard) :: items) =
                (case parseBlockPrefix items
                 of (SOME (stmts, expr), tail) =>
                     let val method =
                             case stmts
                             of stmt :: _ =>
                                 Value.Method (pat, guard,
                                               Value.Block (Value.stmtPos stmt,
                                                            Vector.fromList stmts, expr))
                              | [] => Value.Method (pat, guard, expr)
                         val methods = case tail
                                       of _ :: _ => parseMethods tail
                                        | []     => []
                     in method :: methods
                     end
                  | (NONE, _) => raise Fail "method has no body")
              | parseMethods (_ :: items) = raise Fail "unreachable code reached"
              | parseMethods [] = raise Fail "function has no methods"
        in Value.Fn (pos, Vector.fromList (parseMethods items))
        end

    fun parseBlock pos items =
        case parseBlockPrefix items
        of (SOME (stmts, expr), []) => Value.Block (pos, Vector.fromList stmts, expr)
         | (NONE, []) => raise Fail "empty block"
         | (_, _ :: _) => raise Fail "method header in block"
in fun parseBlockOrFn pos =
       fn items as (MethodHeader _ :: _) => parseFn pos items
        | items => parseBlock pos items
end

(*fun opCall pos opPos opStr l r =
        Cst.FixE (Cst.Expr.Call (pos,
                              Cst.FixE (Cst.Expr.Triv (opPos, Cst.Expr.Triv.Var (BaseVar.Lex
                                                                      (Name.fromString opStr)))),
                   Vector.fromList [l, r]))

fun applyName pos name exprs =
    Cst.FixE (Cst.Expr.Call(pos,
                            Cst.FixE (Cst.Expr.Triv (pos,
                                                     Cst.Expr.Triv.Var (BaseVar.Lex name))), exprs))

fun applyNameRev pos name revExprs =
    applyName pos name (Vector.fromList (List.rev revExprs))

fun extractCall _ [e] = e
  | extractCall pos (f::args) =
    Cst.FixE (Cst.Expr.Call (pos, f, Vector.fromList args))
  | extractCall _ [] = raise LrParser.ParseError *)

%%

%name Pcws

%pos Pos.t

%term LEXID of string
    | DYNID of string
    | OP0 of string
    | OP1 of string
    | OP2 of string
    | OP3 of string
    | OP4 of string
    | OP5 of string
    | OP6 of string
    | OP7 of string
    | PRIM of string

    | INT of string
    | STRING of string
    | CHAR of string

    | EQ
    | AUG
    | DARROW
    | ARROW

    | LPAREN
    | RPAREN
    | LBRACKET
    | RBRACKET
    | LBRACE
    | RBRACE

    | COMMA
    | SEMI

    | EOF

%nonterm program of Value.expr
       | stmt of Value.stmt
       | expr of Value.expr

       (*)| infix0 of Cst.expr
       | infix1 of Cst.expr
       | infix2 of Cst.expr
       | infix3 of Cst.expr
       | infix4 of Cst.expr
       | infix5 of Cst.expr
       | infix6 of Cst.expr
       | infix7 of Cst.expr
       | primCall of Cst.expr
       | simple of Cst.expr *)

       | app of Value.expr
       | appItems of Value.expr list
       | primCall of Value.expr

       | simple of Value.expr

       | id of Value.var

       (*| datum of Cst.expr*)
       | prim of Value.content
       (*| compound of Cst.expr

       | exprList of Cst.expr list
       | exprListTwoPlus of Cst.expr list
       | mapPairs of (Cst.expr * Cst.expr) list*)
       | stmtList of Value.stmt list
       | blockItemList of block_item list

%eop EOF
%noshift EOF

%%

program : expr (Value.Block (exprleft, Vector.fromList [], expr))
        | stmtList SEMI expr (Value.Block (stmtListleft, Vector.fromList (List.rev stmtList),
                                           expr))

stmt : expr EQ expr (Value.Def (expr1, NONE, expr2))
     | expr         (Value.Expr expr)

(*blockItem : app DARROW stmt
            (Clause (Vector.fromList (List.rev app), NONE, stmt))
          | stmt (Stmt stmt)

expr : infix0 (infix0) *)

expr : app      (app)
     | primCall (primCall)

(*infix0 : infix0 OP0 infix1 (opCall infix0left OP0left OP0 infix0 infix1)
       | infix1            (infix1)
infix1 : infix1 OP1 infix2 (opCall infix1left OP1left OP1 infix1 infix2)
       | infix2            (infix2)
infix2 : infix2 OP2 infix3 (opCall infix2left OP2left OP2 infix2 infix3)
       | infix3            (infix3)
infix3 : infix3 OP3 infix4 (opCall infix3left OP3left OP3 infix3 infix4)
       | infix4            (infix4)
infix4 : infix4 OP4 infix5 (opCall infix4left OP4left OP4 infix4 infix5)
       | infix5            (infix5)
infix5 : infix5 OP5 infix6 (opCall infix5left OP5left OP5 infix5 infix6)
       | infix6            (infix6)
infix6 : infix6 OP6 infix7 (opCall infix6left OP6left OP6 infix6 infix7)
       | infix7            (infix7)

infix7 : infix7 OP7 app
            (opCall infix7left OP7left
                   OP7 infix7 (extractCall appleft(List.rev app)))
       | app                (extractCall appleft(List.rev app))
       | infix7 OP7 primCall (opCall infix7left OP7left OP7 infix7 primCall)
       | primCall            (primCall) *)

app : appItems (case List.rev appItems
                of [simple] => simple
                 | callee :: args => Value.Call (appItemsleft, callee, Vector.fromList args)
                 | [] => raise Fail "unreachable")

appItems : simple          ([simple])
         | appItems simple (simple :: appItems)

primCall : PRIM appItems (Value.PrimCall (PRIMleft, PRIM, VectorExt.fromListRev appItems))

(* simple : LPAREN expr RPAREN (expr)
       | LBRACKET stmtList RBRACKET
         (Cst.FixE (Cst.Expr.Fn (LBRACKETleft, NONE, Name.freshFromString "params",
                              Vector.fromList [(Cst.Prolog (Vector.fromList [], NONE),
                                                blockFromStmts LBRACKETleft (List.rev stmtList))])))
       | datum (datum) *)

simple : LBRACE blockItemList RBRACE (parseBlockOrFn LBRACEleft blockItemList)
       | id                          (Value.Var (idleft, id))
       | prim                        (Value.Const (primleft, Value.wrap prim))

id : LEXID (Value.Lex LEXID)
   | DYNID (Value.Dyn DYNID)

(* datum : prim     (prim)
      | compound (compound) *)

prim : INT    (Value.Int (valOf (Int.fromString INT)))
     | STRING (Value.String STRING)
     | CHAR   (Value.Char (String.sub (CHAR, 0)))

(*compound : LPAREN exprList RPAREN
           (applyNameRev LPARENleft (Name.fromString "tuple") exprList)
         | LBRACKET exprList RBRACKET
           (applyNameRev LBRACKETleft (Name.fromString "array") exprList)
         | LBRACE exprList RBRACE
           (applyNameRev LBRACEleft (Name.fromString "set") exprList)
         | LBRACE mapPairs RBRACE
           (let val pos = LBRACEleft
                val args = List.foldl (fn ((k, v), acc) => k::v::acc)
                                      [] mapPairs
            in Cst.FixE (Cst.Expr.Call(pos,
                                    Cst.FixE
                                        (Cst.Expr.Triv (pos, Cst.Expr.Triv.Var (BaseVar.Lex
                                                                     (Name.fromString "hashMap")))),
                       Vector.fromList args)) end)

exprList :                 ([])
         | expr COMMA      ([expr])
         | exprListTwoPlus (exprListTwoPlus)

exprListTwoPlus : expr COMMA expr            ([expr2, expr1])
                | exprListTwoPlus COMMA expr (expr :: exprListTwoPlus)

mapPairs : ARROW                          ([])
         | expr ARROW expr                ([(expr1, expr2)])
         | mapPairs COMMA expr ARROW expr ((expr1, expr2) :: mapPairs) *)

stmtList : stmt               ([stmt])
         | stmtList SEMI stmt (stmt :: stmtList)

blockItemList : expr DARROW blockItemList (MethodHeader (expr, NONE) :: blockItemList)
              | stmt SEMI blockItemList   (Stmt stmt :: blockItemList)
              | stmt                      ([Stmt stmt])
