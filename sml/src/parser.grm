datatype blockItem = Clause of Cst.expr vector * Cst.expr option * Cst.stmt
                   | Stmt of Cst.stmt

fun opApp pos opPos opStr l r =
        Cst.FixE (CExpr.App (pos,
                              Cst.FixE (CExpr.Triv (opPos, CTriv.Var (CTag.Lex,
                                                                      Name.fromString opStr))),
                   Vector.fromList [l, r]))

fun applyName pos name exprs =
    Cst.FixE (CExpr.App(pos, Cst.FixE (CExpr.Triv (pos, CTriv.Var (CTag.Lex, name))), exprs))

fun applyNameRev pos name revExprs =
    applyName pos name (Vector.fromList (List.rev revExprs))

fun extractApp _ [e] = e
  | extractApp pos (f::args) =
    Cst.FixE (CExpr.App (pos, f, Vector.fromList args))
  | extractApp _ [] = raise LrParser.ParseError

fun bareBlockFromStmts stmts = (* OPTIMIZE: *)
    let val Cst.FixS (CStmt.Expr expr) = List.last stmts
    in (Vector.fromList (List.take (stmts, (List.length stmts - 1))), expr)
    end

fun blockFromStmts pos stmts = Cst.FixE (CExpr.Block (pos, bareBlockFromStmts stmts))

fun extractBlock pos (items as (Clause _ :: _)) =
        let fun stmtSplit (Stmt stmt::items) =
                    let val (stmts', items') = stmtSplit items
                    in (stmt::stmts', items') end
              | stmtSplit items = ([], items)
            fun clauses (Clause(formals, cond, stmt)::items) =
                    let val (stmts, items') = stmtSplit items
                        val pos = Cst.exprPos (Vector.sub(formals, 0))
                        val tuple = Name.fromString "tuple"
                    in (Cst.Bind (applyName pos tuple formals, cond),
                        blockFromStmts (Cst.stmtPos stmt) (stmt::stmts))
                       ::clauses items end
              | clauses [] = []
              | clauses _ = raise LrParser.ParseError
        in Cst.FixE (CExpr.Fn (pos, NONE, Vector.fromList (clauses items))) end
  | extractBlock pos (items as (Stmt _ :: _)) =
        let fun unwrapStmt (Stmt stmt) = stmt
              | unwrapStmt (Clause _) = raise LrParser.ParseError
        in blockFromStmts pos (List.map unwrapStmt items)
        end
  | extractBlock _ [] = raise LrParser.ParseError

%%

%name Pcws

%pos Pos.t

%term LEXID of string
    | DYNID of string
    | OP0 of string
    | OP1 of string
    | OP2 of string
    | OP3 of string
    | OP4 of string
    | OP5 of string
    | OP6 of string
    | OP7 of string
    | PRIM of string

    | INT of string
    | STRING of string
    | CHAR of string

    | EQ
    | AUG
    | DARROW
    | ARROW

    | LPAREN
    | RPAREN
    | LBRACKET
    | RBRACKET
    | LBRACE
    | RBRACE

    | COMMA
    | SEMI

    | EOF

%nonterm program of (Cst.expr, Cst.stmt) Block.t
       | stmt of Cst.stmt
       | expr of Cst.expr
       | blockItem of blockItem

       | infix0 of Cst.expr
       | infix1 of Cst.expr
       | infix2 of Cst.expr
       | infix3 of Cst.expr
       | infix4 of Cst.expr
       | infix5 of Cst.expr
       | infix6 of Cst.expr
       | infix7 of Cst.expr
       | app of Cst.expr list
       | primApp of Cst.expr
       | simple of Cst.expr

       | datum of Cst.expr
       | prim of Cst.expr
       | compound of Cst.expr

       | exprList of Cst.expr list
       | exprListTwoPlus of Cst.expr list
       | mapPairs of (Cst.expr * Cst.expr) list
       | stmtList of Cst.stmt list
       | blockItemList of blockItem list

%eop EOF
%noshift EOF

%%

program : stmtList (bareBlockFromStmts (List.rev stmtList))

stmt : expr EQ expr  (Cst.FixS (CStmt.Def (Cst.Bind (expr1, NONE), expr2)))
     | expr AUG expr (Cst.FixS (CStmt.AugDef (Cst.Bind (expr1, NONE), expr2)))
     | expr          (Cst.FixS (CStmt.Expr expr))

blockItem : app DARROW stmt
            (Clause (Vector.fromList (List.rev app), NONE, stmt))
          | stmt (Stmt stmt)

expr : infix0 (infix0)

infix0 : infix0 OP0 infix1 (opApp infix0left OP0left OP0 infix0 infix1)
       | infix1            (infix1)
infix1 : infix1 OP1 infix2 (opApp infix1left OP1left OP1 infix1 infix2)
       | infix2            (infix2)
infix2 : infix2 OP2 infix3 (opApp infix2left OP2left OP2 infix2 infix3)
       | infix3            (infix3)
infix3 : infix3 OP3 infix4 (opApp infix3left OP3left OP3 infix3 infix4)
       | infix4            (infix4)
infix4 : infix4 OP4 infix5 (opApp infix4left OP4left OP4 infix4 infix5)
       | infix5            (infix5)
infix5 : infix5 OP5 infix6 (opApp infix5left OP5left OP5 infix5 infix6)
       | infix6            (infix6)
infix6 : infix6 OP6 infix7 (opApp infix6left OP6left OP6 infix6 infix7)
       | infix7            (infix7)

infix7 : infix7 OP7 app
            (opApp infix7left OP7left
                   OP7 infix7 (extractApp appleft(List.rev app)))
       | app                (extractApp appleft(List.rev app))
       | infix7 OP7 primApp (opApp infix7left OP7left OP7 infix7 primApp)
       | primApp            (primApp)

app : simple     ([simple])
    | app simple (simple :: app)

primApp : PRIM app (Cst.FixE (CExpr.PrimApp (PRIMleft, Primop.fromString PRIM,
                                 Vector.fromList (List.rev app))))

simple : LPAREN expr RPAREN (expr)
       | LBRACE blockItemList RBRACE
         (extractBlock LBRACEleft (List.rev blockItemList))
       | LBRACKET stmtList RBRACKET
         (let val bind =
                  Cst.Bind
                      (applyNameRev
                           LBRACKETleft (Name.fromString "tuple") [],
                       NONE)
          in Cst.FixE (CExpr.Fn (LBRACKETleft, NONE,
                  Vector.fromList [
                      (bind, blockFromStmts LBRACKETleft (List.rev stmtList))]))
          end)
       | LEXID (Cst.FixE (CExpr.Triv (LEXIDleft, CTriv.Var (CTag.Lex, Name.fromString LEXID))))
       | DYNID (Cst.FixE (CExpr.Triv (DYNIDleft, CTriv.Var (CTag.Dyn, Name.fromString DYNID))))
       | datum (datum)

datum : prim     (prim)
      | compound (compound)

prim : INT    (Cst.FixE (CExpr.Triv (INTleft, CTriv.Const (Const.Int INT))))
     | STRING (Cst.FixE (CExpr.Triv (STRINGleft, CTriv.Const (Const.String STRING))))
     | CHAR   (Cst.FixE (CExpr.Triv (CHARleft, CTriv.Const (Const.Char CHAR))))

compound : LPAREN exprList RPAREN
           (applyNameRev LPARENleft (Name.fromString "tuple") exprList)
         | LBRACKET exprList RBRACKET
           (applyNameRev LBRACKETleft (Name.fromString "array") exprList)
         | LBRACE exprList RBRACE
           (applyNameRev LBRACEleft (Name.fromString "set") exprList)
         | LBRACE mapPairs RBRACE
           (let val pos = LBRACEleft
                val args = List.foldl (fn ((k, v), acc) => k::v::acc)
                                      [] mapPairs
            in Cst.FixE (CExpr.App(pos,
                                    Cst.FixE
                                        (CExpr.Triv (pos, CTriv.Var (CTag.Lex,
                                                                     Name.fromString "hashMap"))),
                       Vector.fromList args)) end)

exprList :                 ([])
         | expr COMMA      ([expr])
         | exprListTwoPlus (exprListTwoPlus)

exprListTwoPlus : expr COMMA expr            ([expr2, expr1])
                | exprListTwoPlus COMMA expr (expr :: exprListTwoPlus)

mapPairs : ARROW                          ([])
         | expr ARROW expr                ([(expr1, expr2)])
         | mapPairs COMMA expr ARROW expr ((expr1, expr2) :: mapPairs)

stmtList : stmt               ([stmt])
         | stmtList SEMI stmt (stmt :: stmtList)

blockItemList : blockItem                    ([blockItem])
              | blockItemList SEMI blockItem (blockItem :: blockItemList)
