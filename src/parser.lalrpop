use lexer::{Precedence, Tok, LexicalError, SrcPos};
use lexer::Side::*;
use lexer::Delimiter::*;
use lexer::Separator::*;
use ast::{CST, Const};

use std::str::FromStr;

#[LALR] grammar;

Comma<T>: Vec<T> = {
    <v: (<T> ",")*> <e: T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

CommaT<T>: Vec<T> = {
    <v: (<T> ",")+> => v,
    "," => vec![]
};

CommaPlus<T>: Vec<T> = {
    <v: (<T> ",")*> <e: T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

SemiColon<T>: Vec<T> = {
    <v: (<T> ";")*> <e: T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Infix<Self, Op, Next>: CST = {
    <l: Self> <op: Op> <r: Next> => CST::App(Box::new(CST::Symbol(op)), vec![l, r]),
    <Next>
};

pub Exprs: CST = {
    <stmts: SemiColon<Stmt>> => CST::Block(stmts)
};

pub Expr: CST = {
    <Stmt>
};

Stmt: CST = {
    <lhs: Infix1> <op: Op0> <rhs: Infix1> => match &op as &str {
            "=" => CST::Def(Box::new(lhs), Box::new(rhs)),
            "=>" => CST::Params(Box::new(lhs), Box::new(rhs)),
            _ => unreachable!()
        },
    <Infix1>
};

Infix1: CST = <Infix<Infix1, Op1, Infix2>>;

Infix2: CST = <Infix<Infix2, Op2, Infix3>>;

Infix3: CST = <Infix<Infix3, Op3, Infix4>>;

Infix4: CST = <Infix<Infix4, Op4, Infix5>>;

Infix5: CST = <Infix<Infix5, Op5, Infix6>>;

Infix6: CST = <Infix<Infix6, Op6, Infix7>>;

Infix7: CST = <Infix<Infix7, Op7, App>>;

App: CST = {
    <f: Simple> <args: Simple+> => CST::App(Box::new(f), args),
    <Simple>
};

Simple: CST = {
    "{" <Exprs> "}",
    "(" <Expr> ")",
    <Coll>,
    <Atom>
};

Coll: CST = {
    "(" <elems: CommaT<Expr>> ")"     => CST::Tuple(elems),
    "[" <elems: Comma<Expr>> "]"     => CST::Array(elems)//,
    //"{" <elems: CommaPlus<Expr>> "}" => CST::Set(elems),
    //"{" <kvs: Comma<MapPair>> "}"    => CST::Map(kvs)
};

Atom: CST = {
    Name => CST::Symbol(<>),
    Number => CST::Const(Const::Int(isize::from_str(&<>).unwrap())),
    String => CST::Const(Const::String(<>)),
    Char => CST::Const(Const::Char(<>.chars().next().unwrap()))
};

//MapPair: (CST, CST) = {
//    <key: Expr> ":" <val: Expr> => (key, val)
//};

extern {
    type Location = SrcPos;
    type Error = LexicalError;
    enum Tok {
        Name => Tok::Name(<String>),
        Number => Tok::Number(<String>),
        String => Tok::String(<String>),
        Char => Tok::Char(<String>),
        Op0 => Tok::Op(<String>, Precedence::Zero),
        Op1 => Tok::Op(<String>, Precedence::One),
        Op2 => Tok::Op(<String>, Precedence::Two),
        Op3 => Tok::Op(<String>, Precedence::Three),
        Op4 => Tok::Op(<String>, Precedence::Four),
        Op5 => Tok::Op(<String>, Precedence::Five),
        Op6 => Tok::Op(<String>, Precedence::Six),
        Op7 => Tok::Op(<String>, Precedence::Seven),
        "(" => Tok::Delim(Paren, Left),
        ")" => Tok::Delim(Paren, Right),
        "[" => Tok::Delim(Bracket, Left),
        "]" => Tok::Delim(Bracket, Right),
        "{" => Tok::Delim(Brace, Left),
        "}" => Tok::Delim(Brace, Right),
        "," => Tok::Sep(Comma),
        ";" => Tok::Sep(Semicolon),
    }
}
