use lexer::{Precedence, Tok, LexicalError, SrcPos};
use lexer::Side::*;
use lexer::Delimiter::*;
use lexer::Separator::*;
use ast::{AST, Const, Stmt, Block, Clause, BlockItem, parse_block};

use std::str::FromStr;

#[LALR] grammar;

// Comma<T>: Vec<T> = {
//     <v: (<T> ",")*> <e: T?> => match e {
//         None => v,
//         Some(e) => {
//             let mut v = v;
//             v.push(e);
//             v
//         }
//     }
// };
//
// CommaT<T>: Vec<T> = {
//     <v: (<T> ",")+> => v,
//     "," => vec![]
// };
//
// CommaPlus<T>: Vec<T> = {
//     <v: (<T> ",")*> <e: T> => {
//         let mut v = v;
//         v.push(e);
//         v
//     }
// };

SemiColon<T>: Vec<T> = {
    <v: (<T> ";")*> <e: T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Infix<Self, Op, Next>: AST = {
    <pos: @L> <l: Self> <opos: @L> <op: Op> <r: Next> => AST::App {
        pos: pos,
        op: Box::new(AST::Var { pos: opos, name: op }),
        args: vec![l, r]
    },
    <Next>
};

// ---

pub Exprs: AST = {
    <pos: @L> <stmts: SemiColon<Stmt>> => AST::Block(Block {
        pos: pos,
        stmts: stmts
    })
};

pub Expr: AST = {
    <Infix1>
};

Block: AST = {
    <pos: @L> "{" <items: SemiColon<BlockItem>> "}" => parse_block(pos, items).unwrap() // FIXME
};

BlockItem: BlockItem = {
    <pos: @L> <params: Name> "=>" <stmt: Stmt> => BlockItem::Clause(Clause {
        params: params,
        cond: AST::Const { pos: pos, val: Const::Bool(true) },
        body: Block {
            pos: pos,
            stmts: vec![stmt]
        }
    }),
    <stmt: Stmt> => BlockItem::Stmt(stmt)
};

Stmt: Stmt = {
    <name: Name> "=" <val: Infix1> => Stmt::Def {
        name: name,
        val: val
    },
    <expr: Infix1> => Stmt::Expr(expr)
};

Infix1: AST = <Infix<Infix1, Op1, Infix2>>;

Infix2: AST = <Infix<Infix2, Op2, Infix3>>;

Infix3: AST = <Infix<Infix3, Op3, Infix4>>;

Infix4: AST = <Infix<Infix4, Op4, Infix5>>;

Infix5: AST = <Infix<Infix5, Op5, Infix6>>;

Infix6: AST = <Infix<Infix6, Op6, Infix7>>;

Infix7: AST = <Infix<Infix7, Op7, App>>;

App: AST = {
    <pos: @L> <f: Simple> <args: Simple+> => AST::App {
        pos: pos,
        op: Box::new(f),
        args: args
    },
    <Simple>
};

Simple: AST = {
    <Block>,
    "(" <Expr> ")",
    //<Coll>,
    <Atom>
};

// Coll: AST = {
//     "(" <elems: CommaT<Expr>> ")"     => AST::Tuple(elems),
//     "[" <elems: Comma<Expr>> "]"     => AST::Array(elems)//,
//     //"{" <elems: CommaPlus<Expr>> "}" => CST::Set(elems),
//     //"{" <kvs: Comma<MapPair>> "}"    => CST::Map(kvs)
// };

Atom: AST = {
    <pos: @L> <name: Name> => AST::Var { pos: pos, name: name},
    <pos: @L> <n: Number> => AST::Const {
        pos: pos,
        val: Const::Int(isize::from_str(&n).unwrap())
    },
    <pos: @L> <str: String> => AST::Const {
        pos: pos,
        val: Const::String(str)
    },
    <pos: @L> <c: Char> => AST::Const {
        pos: pos,
        val: Const::Char(c.chars().next().unwrap())
    }
};

//MapPair: (CST, CST) = {
//    <key: Expr> ":" <val: Expr> => (key, val)
//};

extern {
    type Location = SrcPos;
    type Error = LexicalError;
    enum Tok {
        Name => Tok::Name(<String>),
        Number => Tok::Number(<String>),
        String => Tok::String(<String>),
        Char => Tok::Char(<String>),
        Op0 => Tok::Op(<String>, Precedence::Zero),
        Op1 => Tok::Op(<String>, Precedence::One),
        Op2 => Tok::Op(<String>, Precedence::Two),
        Op3 => Tok::Op(<String>, Precedence::Three),
        Op4 => Tok::Op(<String>, Precedence::Four),
        Op5 => Tok::Op(<String>, Precedence::Five),
        Op6 => Tok::Op(<String>, Precedence::Six),
        Op7 => Tok::Op(<String>, Precedence::Seven),
        "(" => Tok::Delim(Paren, Left),
        ")" => Tok::Delim(Paren, Right),
        "[" => Tok::Delim(Bracket, Left),
        "]" => Tok::Delim(Bracket, Right),
        "{" => Tok::Delim(Brace, Left),
        "}" => Tok::Delim(Brace, Right),
        "," => Tok::Sep(Comma),
        ";" => Tok::Sep(Semicolon),
        "=>" => Tok::Arrow,
        "=" => Tok::Eq
    }
}
